<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meshtastic Network Dashboard</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Vis.js CSS - using a stable version -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" />
    
    <!-- Custom CSS -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 60px 1fr 200px;
            height: 100vh;
            gap: 10px;
            padding: 10px;
        }
        
        .header {
            grid-column: 1 / -1;
            background-color: #2d3748;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 30px;
        }
        
        .header-center {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .title {
            font-size: 24px;
            font-weight: bold;
            color: #4fd1c7;
        }
        
        .stats {
            display: flex;
            gap: 20px;
        }
        
        .stat-item {
            text-align: center;
            padding: 5px 10px;
            background-color: #4a5568;
            border-radius: 6px;
            min-width: 80px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #a0aec0;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4fd1c7;
        }
        
        .map-container {
            background-color: #2d3748;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .graph-container {
            background-color: #2d3748;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .panel-title {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(45, 55, 72, 0.9);
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            color: #4fd1c7;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        #network {
            width: 100%;
            height: 100%;
            background-color: #1a202c;
        }
        
        .log-container {
            grid-column: 1 / -1;
            background-color: #2d3748;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .log-header {
            padding: 10px 15px;
            border-bottom: 1px solid #4a5568;
            font-weight: bold;
            color: #4fd1c7;
        }
        
        .log-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 3px 5px;
            border-radius: 3px;
        }
        
        .log-entry.position {
            background-color: rgba(72, 187, 120, 0.1);
            border-left: 3px solid #48bb78;
        }
        
        .log-entry.text {
            background-color: rgba(66, 153, 225, 0.1);
            border-left: 3px solid #4299e1;
        }
        
        .log-entry.telemetry {
            background-color: rgba(237, 137, 54, 0.1);
            border-left: 3px solid #ed8936;
        }
        
        .log-entry.nodeinfo {
            background-color: rgba(159, 122, 234, 0.1);
            border-left: 3px solid #9f7aea;
        }
        
        .timestamp {
            color: #a0aec0;
            font-size: 11px;
        }
        
        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .connection-status.connected {
            background-color: rgba(72, 187, 120, 0.9);
            color: white;
        }
        
        .connection-status.disconnected {
            background-color: rgba(245, 101, 101, 0.9);
            color: white;
        }
        
        .header-search {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-search-input {
            padding: 6px 12px;
            border: 1px solid #4a5568;
            border-radius: 4px;
            background-color: #1a202c;
            color: #e2e8f0;
            font-size: 14px;
            width: 250px;
        }
        
        .header-search-input::placeholder {
            color: #718096;
        }
        
        .header-search-input:focus {
            outline: none;
            border-color: #4fd1c7;
            box-shadow: 0 0 0 2px rgba(79, 209, 199, 0.2);
        }
        
        .header-search-button {
            padding: 6px 12px;
            background-color: #4fd1c7;
            color: #1a202c;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .header-search-button:hover {
            background-color: #38b2ac;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background-color: #1a202c;
            margin: 50px auto;
            padding: 0;
            border: 1px solid #4a5568;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .modal-header {
            background-color: #2d3748;
            padding: 15px 20px;
            border-bottom: 1px solid #4a5568;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            color: #4fd1c7;
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: #a0aec0;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .modal-close:hover {
            background-color: #4a5568;
            color: #e2e8f0;
        }
        
        .modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        /* Keep existing search result styles but remove the search-results class max-height */
        .search-results {
            padding: 0;
            background: transparent;
            border: none;
        }
        
        .search-message {
            padding: 20px;
            text-align: center;
            color: #a0aec0;
            font-style: italic;
        }
        
        .search-result-section {
            background-color: #1a202c;
            border-radius: 6px;
            border: 1px solid #4a5568;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .search-result-section h3 {
            background-color: #2d3748;
            color: #4fd1c7;
            margin: 0;
            padding: 12px 15px;
            font-size: 16px;
            border-bottom: 1px solid #4a5568;
        }
        
        .node-details, .packets-list {
            padding: 15px;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(74, 85, 104, 0.3);
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            font-weight: 600;
            color: #a0aec0;
            min-width: 100px;
        }
        
        .detail-value {
            color: #e2e8f0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .no-packets {
            text-align: center;
            color: #a0aec0;
            font-style: italic;
            padding: 20px;
        }
        
        .packet-item {
            background-color: #2d3748;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 3px solid #4fd1c7;
        }
        
        .packet-item:last-child {
            margin-bottom: 0;
        }
        
        .packet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .packet-time {
            font-size: 12px;
            color: #a0aec0;
            font-family: 'Courier New', monospace;
        }
        
        .packet-type {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .packet-route {
            font-size: 13px;
            color: #e2e8f0;
            margin-bottom: 4px;
            font-family: 'Courier New', monospace;
        }
        
        .packet-channel, .packet-signal {
            font-size: 11px;
            color: #a0aec0;
            margin-bottom: 4px;
        }
        
        .packet-payload {
            background-color: #1a202c;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #e2e8f0;
            margin-top: 8px;
            border-left: 2px solid #38b2ac;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <div class="title">🌐 Meshtastic Network Dashboard</div>
            </div>
            <div class="header-center">
                <div class="header-search">
                    <input type="text" class="header-search-input" id="nodeSearchInput" placeholder="Search node ID (e.g., da639854)...">
                    <button class="header-search-button" onclick="searchNode()">🔍 Search</button>
                </div>
            </div>
            <div class="header-right">
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Nodes</div>
                        <div class="stat-value" id="stat-nodes">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Connections</div>
                        <div class="stat-value" id="stat-connections">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Packets</div>
                        <div class="stat-value" id="stat-packets">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Active</div>
                        <div class="stat-value" id="stat-active">0</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="map-container">
            <div class="panel-title">📍 Node Locations</div>
            <div class="connection-status" id="connection-status">Connecting...</div>
            <div id="map"></div>
        </div>
        
        <div class="graph-container">
            <div class="panel-title">🔗 Network Graph</div>
            <div id="network"></div>
        </div>
        
        <div class="log-container">
            <div class="log-header">📡 Live Activity Feed</div>
            <div class="log-content" id="log-content">
                <div class="log-entry">
                    <span class="timestamp">Waiting for data...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Search Results Modal -->
    <div id="searchModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Node Search Results</h2>
                <button class="modal-close" onclick="closeSearchModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="searchResults">
                    <!-- Search results will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Vis.js - using stable version that should definitely work -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    
    <!-- Socket.IO -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.js"></script>
    
    <script>
        // Global variables
        let map, network, socket;
        let nodes, edges;
        let mapMarkers = {};
        let connectionLines = {};
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded');
            
            // Setup search input event listener
            const searchInput = document.getElementById('nodeSearchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        searchNode();
                    }
                });
            }
            
            // Setup modal close on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeSearchModal();
                }
            });
            
            // Wait a bit for vis.js to load
            setTimeout(function() {
                console.log('Checking vis availability...');
                console.log('typeof vis:', typeof vis);
                
                if (typeof vis === 'undefined') {
                    console.error('vis.js library is not available');
                    document.getElementById('network').innerHTML = 
                        '<div style="color: white; text-align: center; padding: 50px; font-size: 16px;">' +
                        '⚠️ Network graph unavailable<br>' +
                        '<small>vis.js library failed to load</small></div>';
                } else {
                    console.log('vis.js is available, version:', vis.version);
                    // Initialize vis DataSets
                    nodes = new vis.DataSet();
                    edges = new vis.DataSet();
                    console.log('DataSets created');
                }
                
                // Initialize other components
                initializeMap();
                if (typeof vis !== 'undefined') {
                    initializeNetwork();
                }
                initializeWebSocket();
                loadInitialData();
            }, 500);
        });
        
        function initializeMap() {
            // Initialize OpenStreetMap
            map = L.map('map').setView([39.4, -8.2], 8); // Portugal center
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            // Clear any existing markers
            mapMarkers = {};
            
            // Custom marker styles
            window.nodeMarkerStyles = {
                default: { color: '#4fd1c7', radius: 8 },
                active: { color: '#48bb78', radius: 10 },
                inactive: { color: '#a0aec0', radius: 6 }
            };
        }
        
        function initializeNetwork() {
            // Check if vis is available
            if (typeof vis === 'undefined') {
                console.error('vis.js is not available for network initialization');
                document.getElementById('network').innerHTML = '<div style="color: white; text-align: center; padding: 50px;">Network graph unavailable - vis.js not loaded</div>';
                return;
            }
            
            // Initialize network graph
            const container = document.getElementById('network');
            const data = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: {
                        size: 12,
                        color: '#ffffff'
                    },
                    borderWidth: 2,
                    color: {
                        border: '#4fd1c7',
                        background: '#2d3748',
                        highlight: {
                            border: '#4fd1c7',
                            background: '#4a5568'
                        }
                    }
                },
                edges: {
                    width: 2,
                    color: {
                        color: '#4a5568',
                        highlight: '#4fd1c7'
                    },
                    arrows: {
                        to: { enabled: true, scaleFactor: 0.8 }
                    },
                    smooth: {
                        enabled: true,
                        type: 'continuous'
                    }
                },
                physics: {
                    enabled: true,
                    stabilization: { iterations: 200 },
                    barnesHut: {
                        gravitationalConstant: -8000,
                        springConstant: 0.001,
                        springLength: 200
                    }
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 200
                }
            };
            
            network = new vis.Network(container, data, options);
            
            // Network event handlers
            network.on('click', function(params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    highlightNode(nodeId);
                }
            });
        }
        
        function initializeWebSocket() {
            socket = io();
            
            socket.on('connect', function() {
                updateConnectionStatus(true);
                addLogEntry('system', 'Connected to dashboard server');
            });
            
            socket.on('disconnect', function() {
                updateConnectionStatus(false);
                addLogEntry('system', 'Disconnected from dashboard server');
            });
            
            socket.on('node_update', function(data) {
                updateNode(data);
            });
            
            socket.on('connection_update', function(data) {
                updateConnection(data);
            });
            
            socket.on('packet_update', function(data) {
                handlePacketUpdate(data);
            });
        }
        
        function loadInitialData() {
            // Load all nodes (updateNode handles both graph and map)
            fetch('/api/nodes')
                .then(response => response.json())
                .then(data => {
                    data.forEach(node => updateNode(node));
                    // Auto-fit map to show all markers after loading
                    setTimeout(() => {
                        if (Object.keys(mapMarkers).length > 0) {
                            const group = new L.featureGroup(Object.values(mapMarkers));
                            map.fitBounds(group.getBounds().pad(0.1));
                        }
                    }, 100);
                })
                .catch(error => console.error('Error loading nodes:', error));
            
            // Load connections
            fetch('/api/connections')
                .then(response => response.json())
                .then(data => {
                    data.forEach(connection => updateConnection(connection));
                })
                .catch(error => console.error('Error loading connections:', error));
            
            // Load stats
            updateStats();
            setInterval(updateStats, 10000); // Update every 10 seconds
        }
        
        function ensureNodeExists(nodeId) {
            if (!nodeId || nodeId === 'ffffffff') return; // Skip invalid or broadcast IDs
            
            if (typeof vis !== 'undefined' && nodes && !nodes.get(nodeId)) {
                // Create placeholder node
                const placeholderNode = {
                    id: nodeId,
                    label: nodeId.slice(-4), // Show last 4 characters
                    title: `Node ID: ${nodeId}\nStatus: Unknown`,
                    color: {
                        border: '#a0aec0',
                        background: '#e2e8f0',
                        highlight: {
                            border: '#718096',
                            background: '#cbd5e0'
                        }
                    }
                };
                
                nodes.add(placeholderNode);
            }
        }
        
        function updateNode(nodeData) {
            const nodeId = nodeData.node_id;
            const hasPosition = nodeData.latitude != null && nodeData.longitude != null && 
                               nodeData.latitude !== '' && nodeData.longitude !== '' &&
                               !isNaN(nodeData.latitude) && !isNaN(nodeData.longitude);
            
            // Always update network graph node (show all nodes in graph)
            if (typeof vis !== 'undefined' && nodes) {
                const networkNode = {
                    id: nodeId,
                    label: nodeData.short_name || nodeData.long_name || nodeId.slice(-4),
                    title: `${nodeData.long_name || 'Unknown'}\nID: ${nodeId}\nLast seen: ${nodeData.last_seen || 'Never'}`,
                    // Color nodes with position in green, others in default
                    color: hasPosition ? {
                        border: '#48bb78',
                        background: '#68d391',
                        highlight: {
                            border: '#38a169',
                            background: '#9ae6b4'
                        }
                    } : undefined
                };
                
                if (nodes.get(nodeId)) {
                    nodes.update(networkNode);
                } else {
                    nodes.add(networkNode);
                }
            }
            
            // Update map marker only if node has position
            if (hasPosition) {
                updateMapMarker(nodeData);
            }
            
            // Check if any existing connections can now draw map lines
            redrawMapConnectionsForNode(nodeId);
            
            addLogEntry('nodeinfo', `Node ${nodeData.short_name || nodeId.slice(-4)} updated`);
        }
        
        function updateMapMarker(nodeData) {
            const nodeId = nodeData.node_id;
            const lat = nodeData.latitude;
            const lon = nodeData.longitude;
            
            if (!lat || !lon || !map || lat == null || lon == null || 
                lat === '' || lon === '' || isNaN(lat) || isNaN(lon)) {
                return; // Skip if no valid coordinates or map not ready
            }
            
            if (mapMarkers[nodeId]) {
                mapMarkers[nodeId].setLatLng([lat, lon]);
            } else {
                const marker = L.circleMarker([lat, lon], {
                    radius: 8,
                    fillColor: '#4fd1c7',
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);
                
                marker.bindPopup(`
                    <b>${nodeData.long_name || nodeData.short_name || 'Unknown'}</b><br>
                    ID: ${nodeId}<br>
                    ${nodeData.battery_level ? `Battery: ${nodeData.battery_level}%<br>` : ''}
                    ${nodeData.last_seen ? `Last seen: ${new Date(nodeData.last_seen).toLocaleString()}` : ''}
                `);
                
                // Add click event to focus on node in graph
                marker.on('click', function() {
                    focusOnNodeInGraph(nodeId);
                });
                
                mapMarkers[nodeId] = marker;
            }
            
            // Check if any existing connections can now draw map lines
            redrawMapConnectionsForNode(nodeId);
        }
        
        function redrawMapConnectionsForNode(nodeId) {
            // Look through all existing edges in the network to find connections involving this node
            if (typeof vis !== 'undefined' && edges) {
                const allEdges = edges.get();
                allEdges.forEach(edge => {
                    if (edge.from === nodeId || edge.to === nodeId) {
                        const fromMarker = mapMarkers[edge.from];
                        const toMarker = mapMarkers[edge.to];
                        
                        if (fromMarker && toMarker) {
                            const edgeId = edge.id;
                            
                            // Only create line if it doesn't exist yet
                            if (!connectionLines[edgeId]) {
                                const line = L.polyline([
                                    fromMarker.getLatLng(),
                                    toMarker.getLatLng()
                                ], {
                                    color: '#4fd1c7',
                                    weight: 2,
                                    opacity: 0.7
                                }).addTo(map);
                                
                                line.bindPopup(`
                                    <b>Connection</b><br>
                                    From: ${edge.from.slice(-4)}<br>
                                    To: ${edge.to.slice(-4)}<br>
                                    ${edge.title || ''}
                                `);
                                
                                connectionLines[edgeId] = line;
                            }
                        }
                    }
                });
            }
        }
        
        function focusOnNodeInGraph(nodeId) {
            if (typeof vis !== 'undefined' && network && nodes) {
                // Check if the node exists in the graph
                const node = nodes.get(nodeId);
                if (node) {
                    // Focus on the node with animation
                    network.focus(nodeId, {
                        scale: 1.0,
                        animation: {
                            duration: 500,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                    
                    // Select the node to highlight it
                    network.selectNodes([nodeId]);
                }
            }
        }
        
        function updateConnection(connectionData) {
            const edgeId = `${connectionData.from_node}-${connectionData.to_node}`;
            
            // Ensure both nodes exist (create placeholders if needed)
            ensureNodeExists(connectionData.from_node);
            ensureNodeExists(connectionData.to_node);
            
            // Update network graph edge (only if vis.js is available)
            if (typeof vis !== 'undefined' && edges) {
                const edge = {
                    id: edgeId,
                    from: connectionData.from_node,
                    to: connectionData.to_node,
                    label: `${connectionData.packet_count}`,
                    title: `Packets: ${connectionData.packet_count}\nAvg SNR: ${connectionData.avg_snr?.toFixed(1) || 'N/A'}\nAvg RSSI: ${connectionData.avg_rssi || 'N/A'}`
                };
                
                if (edges.get(edgeId)) {
                    edges.update(edge);
                } else {
                    edges.add(edge);
                }
            }
            
            // Update map connection line
            const fromMarker = mapMarkers[connectionData.from_node];
            const toMarker = mapMarkers[connectionData.to_node];
            
            if (fromMarker && toMarker) {
                const lineId = edgeId;
                
                if (connectionLines[lineId]) {
                    map.removeLayer(connectionLines[lineId]);
                }
                
                const line = L.polyline([
                    fromMarker.getLatLng(),
                    toMarker.getLatLng()
                ], {
                    color: '#4fd1c7',
                    weight: Math.min(connectionData.packet_count / 10 + 1, 5),
                    opacity: 0.6
                }).addTo(map);
                
                line.bindPopup(`
                    Connection: ${connectionData.from_node.slice(-4)} → ${connectionData.to_node.slice(-4)}<br>
                    Packets: ${connectionData.packet_count}<br>
                    Avg SNR: ${connectionData.avg_snr?.toFixed(1) || 'N/A'}<br>
                    Last seen: ${new Date(connectionData.last_seen).toLocaleString()}
                `);
                
                connectionLines[lineId] = line;
            }
        }
        
        function handlePacketUpdate(packetData) {
            const type = packetData.payload_type || 'unknown';
            const from = packetData.from_node?.slice(-4) || 'Unknown';
            const to = packetData.to_node?.slice(-4) || 'Broadcast';
            
            let message = `${from} → ${to}: ${type}`;
            if (packetData.payload_data) {
                try {
                    const payload = JSON.parse(packetData.payload_data);
                    if (payload.message) {
                        message += ` "${payload.message}"`;
                    } else if (payload.latitude && payload.longitude) {
                        message += ` (${payload.latitude.toFixed(4)}, ${payload.longitude.toFixed(4)})`;
                    }
                } catch (e) {
                    // Ignore parsing errors
                }
            }
            
            addLogEntry(type, message);
        }
        
        function updateStats() {
            fetch('/api/stats')
                .then(response => response.json())
                .then(stats => {
                    document.getElementById('stat-nodes').textContent = stats.total_nodes || 0;
                    document.getElementById('stat-connections').textContent = stats.active_connections || 0;
                    document.getElementById('stat-packets').textContent = stats.recent_packets || 0;
                    document.getElementById('stat-active').textContent = stats.nodes_with_position || 0;
                })
                .catch(error => console.error('Error updating stats:', error));
        }
        
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            if (connected) {
                statusElement.textContent = 'Connected';
                statusElement.className = 'connection-status connected';
            } else {
                statusElement.textContent = 'Disconnected';
                statusElement.className = 'connection-status disconnected';
            }
        }
        
        function addLogEntry(type, message) {
            const logContent = document.getElementById('log-content');
            const timestamp = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `
                <span class="timestamp">[${timestamp}]</span> ${message}
            `;
            
            logContent.insertBefore(entry, logContent.firstChild);
            
            // Keep only last 100 entries
            while (logContent.children.length > 100) {
                logContent.removeChild(logContent.lastChild);
            }
        }
        
        function highlightNode(nodeId) {
            // Highlight node on map
            if (mapMarkers[nodeId]) {
                mapMarkers[nodeId].openPopup();
                map.setView(mapMarkers[nodeId].getLatLng(), 12);
            }
        }
        
        // Search functionality
        async function searchNode() {
            const input = document.getElementById('nodeSearchInput');
            const modal = document.getElementById('searchModal');
            const resultsDiv = document.getElementById('searchResults');
            const searchTerm = input.value.trim();
            
            if (!searchTerm) {
                alert('Please enter a node ID to search');
                return;
            }
            
            // Show modal and loading message
            modal.style.display = 'block';
            resultsDiv.innerHTML = '<div class="search-message">🔍 Searching...</div>';
            
            try {
                // Search for the node
                const nodeResponse = await fetch(`/api/search/node/${encodeURIComponent(searchTerm)}`);
                
                if (!nodeResponse.ok) {
                    if (nodeResponse.status === 404) {
                        resultsDiv.innerHTML = '<div class="search-message">❌ Node not found</div>';
                    } else {
                        resultsDiv.innerHTML = '<div class="search-message">❌ Error searching for node</div>';
                    }
                    return;
                }
                
                const nodeData = await nodeResponse.json();
                
                // Get packets for this node
                const packetsResponse = await fetch(`/api/packets/node/${encodeURIComponent(searchTerm)}`);
                let packets = [];
                if (packetsResponse.ok) {
                    packets = await packetsResponse.json();
                }
                
                // Display results
                displaySearchResults(nodeData, packets);
                
                // Highlight the node on map and graph
                highlightSearchedNode(nodeData.node_id);
                
            } catch (error) {
                console.error('Search error:', error);
                resultsDiv.innerHTML = '<div class="search-message">❌ Error occurred during search</div>';
            }
        }
        
        function closeSearchModal() {
            const modal = document.getElementById('searchModal');
            modal.style.display = 'none';
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('searchModal');
            if (event.target === modal) {
                closeSearchModal();
            }
        }
        
        function displaySearchResults(nodeData, packets) {
            const resultsDiv = document.getElementById('searchResults');
            
            // Format node information
            const hasPosition = nodeData.latitude && nodeData.longitude;
            const lastSeen = nodeData.last_seen ? new Date(nodeData.last_seen).toLocaleString() : 'Never';
            
            let nodeInfo = `
                <div class="search-result-section">
                    <h3>🔍 Node Details</h3>
                    <div class="node-details">
                        <div class="detail-row">
                            <span class="detail-label">ID:</span>
                            <span class="detail-value">!${nodeData.node_id}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Long Name:</span>
                            <span class="detail-value">${nodeData.long_name || 'Unknown'}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Short Name:</span>
                            <span class="detail-value">${nodeData.short_name || 'Unknown'}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Hardware:</span>
                            <span class="detail-value">${nodeData.hardware_model || 'Unknown'}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Position:</span>
                            <span class="detail-value">${hasPosition ? 
                                `${nodeData.latitude.toFixed(6)}, ${nodeData.longitude.toFixed(6)}` : 
                                'No position data'}</span>
                        </div>
                        <div class="detail-row">
                            <span class="detail-label">Last Seen:</span>
                            <span class="detail-value">${lastSeen}</span>
                        </div>
                        ${nodeData.battery_level ? `
                        <div class="detail-row">
                            <span class="detail-label">Battery:</span>
                            <span class="detail-value">${nodeData.battery_level}%</span>
                        </div>` : ''}
                        ${nodeData.snr ? `
                        <div class="detail-row">
                            <span class="detail-label">SNR:</span>
                            <span class="detail-value">${nodeData.snr} dB</span>
                        </div>` : ''}
                        ${nodeData.rssi ? `
                        <div class="detail-row">
                            <span class="detail-label">RSSI:</span>
                            <span class="detail-value">${nodeData.rssi} dBm</span>
                        </div>` : ''}
                    </div>
                </div>
            `;
            
            // Format recent packets/messages
            let packetsInfo = `
                <div class="search-result-section">
                    <h3>📡 Recent Messages (Last 24 Hours)</h3>
                    <div class="packets-list">
            `;
            
            if (packets.length === 0) {
                packetsInfo += '<div class="no-packets">No messages found in the last 24 hours</div>';
            } else {
                packets.forEach(packet => {
                    const timestamp = new Date(packet.timestamp).toLocaleString();
                    const portTypeMap = {
                        '1': 'TEXT_MESSAGE_APP',
                        '3': 'POSITION_APP',
                        '4': 'NODEINFO_APP',
                        '67': 'TELEMETRY_APP',
                        '71': 'NEIGHBORINFO_APP'
                    };
                    const portName = portTypeMap[packet.port_num] || `Port ${packet.port_num}`;
                    
                    packetsInfo += `
                        <div class="packet-item">
                            <div class="packet-header">
                                <span class="packet-time">${timestamp}</span>
                                <span class="packet-type">${portName}</span>
                            </div>
                            <div class="packet-route">
                                From: <strong>!${packet.from_node}</strong> → To: <strong>!${packet.to_node}</strong>
                                ${packet.gateway_id && packet.gateway_id !== packet.from_node && packet.gateway_id !== packet.to_node ? 
                                    ` via <strong>!${packet.gateway_id}</strong>` : ''}
                            </div>
                            ${packet.channel ? `<div class="packet-channel">Channel: ${packet.channel}</div>` : ''}
                            ${(packet.snr || packet.rssi) ? `
                                <div class="packet-signal">
                                    ${packet.snr ? `SNR: ${packet.snr} dB ` : ''}
                                    ${packet.rssi ? `RSSI: ${packet.rssi} dBm` : ''}
                                </div>
                            ` : ''}
                            ${packet.payload_data && packet.port_num === '1' ? `
                                <div class="packet-payload">${packet.payload_data}</div>
                            ` : ''}
                        </div>
                    `;
                });
            }
            
            packetsInfo += '</div></div>';
            
            resultsDiv.innerHTML = nodeInfo + packetsInfo;
        }
        
        function highlightSearchedNode(nodeId) {
            // Highlight on map if node has position
            if (mapMarkers[nodeId]) {
                mapMarkers[nodeId].openPopup();
                map.setView(mapMarkers[nodeId].getLatLng(), 12);
            }
            
            // Highlight on network graph
            if (network && nodes) {
                const nodeExists = nodes.get(nodeId);
                if (nodeExists) {
                    network.selectNodes([nodeId]);
                    network.focus(nodeId, {
                        scale: 1.5,
                        animation: {
                            duration: 1000,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                }
            }
        }
    </script>
</body>
</html>
